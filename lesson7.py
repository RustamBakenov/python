#1. Реализовать класс Matrix (матрица). Обеспечить перегрузку конструктора класса (метод __init__()), который должен
# принимать данные (список списков) для формирования матрицы.
#Подсказка: матрица — система некоторых математических величин, расположенных в виде прямоугольной схемы.
#Примеры матриц вы найдете в методичке.
#Следующий шаг — реализовать перегрузку метода __str__() для вывода матрицы в привычном виде.
#Далее реализовать перегрузку метода __add__() для реализации операции сложения двух объектов класса Matrix (двух матриц).
# Результатом сложения должна быть новая матрица.
#Подсказка: сложение элементов матриц выполнять поэлементно — первый элемент первой строки первой матрицы складываем с
# первым элементом первой строки второй матрицы и т.д.

class Matrix:
    def __init__(self, list):
        self.list = list

    def __str__(self):
        for i in range(len(self.list)):
            for j in range(len(self.list[i])):
                print(str(self.list[i][j]), end=' ')
            print()

    def __add__(self, other):
        result = [[self.list[i][j] + other.list[i][j] for j in range(len(self.list[0]))] for i in range(len(self.list))]
        for x in range(len(result)):
            for y in range(len(result[x])):
                print(str(result[x][y]), end=' ')
            print()

matrix1 = Matrix([[1, 2, 3], [3, 4, 5], [2, 5, 6]])
matrix2 = Matrix([[8, 6, 8], [3, 5, 6], [2, 9, 3]])
matrix1.__str__()
print()
matrix2.__str__()
print()
matrix1.__add__(matrix2)

#2. Реализовать проект расчета суммарного расхода ткани на производство одежды. Основная сущность (класс) этого проекта
# — одежда, которая может иметь определенное название. К типам одежды в этом проекте относятся пальто и костюм. У этих
# типов одежды существуют параметры: размер (для пальто) и рост (для костюма). Это могут быть обычные числа: V и H,
# соответственно.
#Для определения расхода ткани по каждому типу одежды использовать формулы: для пальто (V/6.5 + 0.5), для костюма (2 * H + 0.3).
# Проверить работу этих методов на реальных данных.
#Реализовать общий подсчет расхода ткани. Проверить на практике полученные на этом уроке знания: реализовать абстрактные
# классы для основных классов проекта, проверить на практике работу декоратора @property.

from abc import ABC, abstractmethod

class Garments(ABC):
    def __init__(self, name):
        self.name = name
    @abstractmethod
    def get_expense(self, value):
        pass

class Coat(Garments):
    def __init__(self, name, v):
        self.name = name
        self.v = v

    @property
    def get_expense(self):
        return self.v / 6.5 + 0.5

class Costume(Garments):
    def __init__(self, name, h):
        self.name = name
        self.h = h

    @property
    def get_expense(self):
        return 2 * self.h + 0.3

coat = Coat('Пальто', 60)
a = coat.get_expense
costume = Costume('Костюм', 185)
b = costume.get_expense
print(a + b)

#3. Реализовать программу работы с органическими клетками. Необходимо создать класс Клетка. В его конструкторе
# инициализировать параметр, соответствующий количеству клеток (целое число). В классе должны быть реализованы методы
# перегрузки арифметических операторов: сложение (__add__()), вычитание (__sub__()), умножение (__mul__()),
# деление (__truediv__()).Данные методы должны применяться только к клеткам и выполнять увеличение, уменьшение,
# умножение и обычное (не целочисленное) деление клеток, соответственно. В методе деления должно осуществляться округление
# значения до целого числа.
#Сложение. Объединение двух клеток. При этом число ячеек общей клетки должно равняться сумме ячеек исходных двух клеток.
#Вычитание. Участвуют две клетки. Операцию необходимо выполнять только если разность количества ячеек двух клеток больше
# нуля, иначе выводить соответствующее сообщение.
#Умножение. Создается общая клетка из двух. Число ячеек общей клетки определяется как произведение количества ячеек этих двух клеток.
#Деление. Создается общая клетка из двух. Число ячеек общей клетки определяется как целочисленное деление количества ячеек этих двух клеток.
#В классе необходимо реализовать метод make_order(), принимающий экземпляр класса и количество ячеек в ряду.
# Данный метод позволяет организовать ячейки по рядам.
#Метод должен возвращать строку вида *****\n*****\n*****..., где количество ячеек между \n равно переданному аргументу.
# Если ячеек на формирование ряда не хватает, то в последний ряд записываются все оставшиеся.
#Например, количество ячеек клетки равняется 12, количество ячеек в ряду — 5. Тогда метод make_order() вернет
# строку: *****\n*****\n**.
#Или, количество ячеек клетки равняется 15, количество ячеек в ряду — 5. Тогда метод make_order() вернет
# строку: *****\n*****\n*****.
#Подсказка: подробный список операторов для перегрузки доступен по ссылке.

class Cell:
    def __init__(self, count_cell):
        self.count_cell = int(count_cell)
        print('*' * self.count_cell)

    def __add__(self, other):
        return '*' * (self.count_cell + other.count_cell)

    def __sub__(self, other):
        result = self.count_cell - other.count_cell
        if result >= 0:
            return '*' * result
        else:
            return 'Результат меньше нуля'

    def __mul__(self, other):
        return '*' * (self.count_cell * other.count_cell)

    def __truediv__(self, other):
        return '*' * (self.count_cell // other.count_cell)

    def make_order(self, count):
        if self.count_cell % count == 0:
            for i in range(self.count_cell//count):
                print('*' * count, end='\n')
        else:
            for i in range(self.count_cell//count):
                print('*' * count, end='\n')
            print('*' * (self.count_cell % count), end='\n')

a = Cell(14)
b = Cell(3)
print(a + b)
print(a - b)
print(a * b)
print(a / b)
a.make_order(3)